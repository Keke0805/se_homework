**第12章 基本数据类型**
---------------

### **12.1 数值概论**

1.  避免使用“神秘数值”：这样会使修改更可靠、更容易，并增加代码的可读性
2.  如果需要，可以使用硬编码的0和1，其他值都要有描述性表示
3.  预防除零错误：每次用到除法的时候，都要检查分母是否为0
4.  事类型转换变得明显
5.  避免混合类型的比较
6.  注意编译器的警告

### **12.2 整数**

1.  检查整数除法：7/10在整数除法中的结果为0
2.  检查整数溢出：在做整数乘法或加法的时候，要留心可能的最大整数
3.  检查中间结果溢出

### **12.3 浮点数**

1.  避免数量级相差巨大的数之间的加减运算
2.  避免等量判断：浮点数不能用==来判断，可以用两个值的差与可以接受的误差值作比较
3.  处理摄入误差问题
4.  检查语言和函数库对特定数据类型的支持

### **12.4 字符和字符串**

1.  避免使用神秘字符和神秘字符串
2.  避免off-by-one错误：下标索引的问题
3.  了解你的语言和开发环境是如何支持Unicode的：Java等语言里，所有的字符串都是Unicode的，在C和C++等其他的语言里，处理Unicode就要用到阈值相关的一组函数
4.  在程序生命期中尽早决定国际化/本地化策略
5.  如果你知道只需要支持一种文字的 语言，请考虑使用ISO8859字符集
6.  如果你需要支持多种语言，请使用Unicode
7.  采用某种一致的字符串类型转换策略

****C语言中的字符串****

1.  注意字符指针和字符数组之间的差异：用命名规则区分变量是字符数组还是字符串指针
2.  把C-style字符串的长度声明为CONSTANT+1：这样就可以用来处理off-by-one的问题
3.  用null初始化字符串以避免没有结束的字符串：因为c语言中判断字符串长度都用末尾为0的字节来判断，所以字符数组声明时最好初始为0，分配内存给指针时，最好用calloc（）函数，因为这个函数会负责分配内存，并把它初始化为0
4.  用字符数组取代C中的指针：如果内存不是限制性因素的话，字符数组有助于避免指针错误，并且在错误的时候，编译器会给你更多的警告
5.  用strncpy（）取代strcpy（）以避免无结束的字符串

### **12.5 布尔变量**

1.  用布尔变量对程序加以文档说明

2.  用布尔变量来简化复杂的判断：我觉得跟第一条差不多，定义变量来获取条件判断的值，这样可以用变量名来自解释程序执行的意图
3.  如果需要的话，创建你自己的布尔类型：c语言没有预定义的布尔类型

### **12.6 枚举类型**

1.  用枚举类型来提高可读性
2.  用枚举类型来提高可靠性
3.  用枚举类型来简化修改
4.  将枚举类型作为布尔变量的替换方案
5.  检查非法数值
6.  定义出枚举的第一项和最后一项，以便用于循环边界
7.  把枚举类型的第一个元素留作非法值
8.  明确定义项目代码编写标准中第一个和最后一个元素的使用规则，并且在使用时保持一致
9.  警惕给枚举元素明确赋值而带来的失误

### **12.7 具名常量**

1.  在数据声明中使用具名常量
2.  避免使用文字量，即使是“安全”的
3.  统一地使用具名常量

### **12.8 数组**

1.  确认所有的数组下标都没有超出数组的边界
2.  考虑用容器来取代数组，或者将数组作为顺序化结构来处理
3.  检查数组的边界点
4.  如果数组是多维的，确认下标的使用顺序是正确的
5.  提防下标串话：就是i和j用错位置，解决的办法就是将i、j换为更有意义的下标名
6.  在C中结合ARRAY_LENGTH()宏来使用数组

### **12.9 创建你自己的类型**

****创建你自己类型的原因****

1.  易于修改
2.  避免过多的信息分发
3.  增加可靠性
4.  弥补语言的不足

****创建自定义数据类型的指导原则****

1.  \*\* 给所创建的类型取功能导向的名字**
2.  避免使用预定义类型
3.  不要重定义一个预定义的类型
4.  定义替代类型以便于移植：也就是给预定义类型typedef其他名字，方便平台间的移植和可读性

****要点****

1.  使用特定的数据类型就意味着要记住适用于各个类型的很多独立的原则
2.  如果你的语言支持，创建自定义类型会使得你的程序更容易修改，并更具有自描述性
3.  当你用typedef或者其等价方式创建了一个简单类型的时候，考虑是否更应该创建一个新的类

### **第13章 不常见的数据类型**

### **13.1 结构体**

1.  用结构体来明确数据关系
2.  用结构体简化对数据块的操作：分散的数据就只能一个一个去赋值，如果是结构体那么就能直接memcpy
3.  用结构体来简化参数列表
4.  用结构体来较少维护

### **13.2 指针**

****用来理解指针的范例****

1.  内存中的位置：常用16进制形式表示，在32位处理器中是一个32位的值
2.  如何解释指针所指的内容：与指针的类型有很大关系

****使用指针的一般技巧****

1.  把指针操作限制在子程序或者类里面：这样可以把对指针的操作集中起来，便于查找指针错误操作
2.  同时声明和定义指针
3.  在于指针分配相同的作用域中删除指针：保持指针分配和释放操作的对称性
4.  在使用指针之前检查指针：在使用 一个指针之前，要确保它指向的内存位置是合理的
5.  先检查指针所引用的变量再使用它：对指针所指向的数据执行合理性检查
6.  用狗牌字段来检测损毁的内存：大概的意思就是你在指针指向的内存中放入特定的字段，当你释放的时候来检查这个字段，如果这个字段的数据被修改了，那么就可以断定操作这个地址的指针被误操作了
7.  增加明显的冗余：另一种判断内存数据是否被破坏了的方法，其实我觉得6 7这两种方式都不适合用在程序里面，而更适合在调试代码的时候，用于排除是否为指针的误操作
8.  用额外的指针变量来提高代码清晰度
9.  简化复杂的指针表达式

10.  画一个图
11.  按照正确的顺序删除链表中的指针
12.  分配一片保留的内存后备区域：对于嵌入式的程序而言，这个有点不太适合，嵌入式mcu的ram空间本来就不大
13.  粉碎垃圾数据：在要释放的指针指向的内存中写入垃圾数据，释放之后，就不会错用数据了
14.  在删除或者释放指针之后把它们设为空值
15.  在删除变量之前检查非法指针：避免二次删除释放指针
16.  跟踪指针分配情况
17.  编写覆盖子程序，集中实现避免指针问题的策略：就是用宏定义或子程序来实现指针的分配和释放，这样其实跟1的效果差不多，都是为了更方便的排除问题
18.  采用非指针的技术

****C++指针****

1.  理解指针和引用之间的区别：引用必须被初始化，因此引用总是引用一个对象，而指针则可以指向空值
2.  把指针用于“按引用传递”参数，把const引用用于“按值传递”参数：没看懂
3.  使用auto_ptr
4.  灵活运用智能指针：对C++中的智能指针不太了解

****C指针****

1.  使用显式指针类型而不是默认类型
2.  避免强制类型转换：我觉得强制类型转换才体现了指针的灵活性，不知道是否正确，因为这部分也没说明强制转换有什么坏处
3.  遵循参数传递的星号规则

4.  在内存分配中使用sizeof()确定变量的大小：由于sizeof是在编译期间计算的，因此不会带来性能上的损失

### **13.3 全局数据**

大多数有经验的程序员已经得出结论：使用全局数据的风险比使用局部数据大

****与全局数据有关的常见问题****

1.  无意间修改了全局数据
2.  与全局数据有关的奇异的和令人激动的别名问题：这是vb程序的一个问题，但我觉得对于C程序，不会出现这个问题，希望有某个大神给予指正
3.  与全局数据有关的代码重入问题：由于多线程应用的问题，全局数据会存在共享等问题
4.  全局数据阻碍代码重用
5.  与全局数据有关的非确定的初始化顺序事宜：全局变量相关性
6.  全局数据破坏了模块化和智力上的可管理性：处理大型程序最核心的方法就是管理复杂度，你你能够在智力上管理一个大型程序的唯一方法就是把它拆分成几部分，也就是模块化，而全局数据会使得你的模块化能力大打折扣

****使用全局数据的理由****

1.  保存全局数值：这可能是一个用于表示程序状态的变量
2.  模拟具名常量：针对Python等不支持具名常量的语言而言的
3.  模拟枚举类型：针对Python等不支持枚举类型的语言而言的
4.  简化对极其常用的数据的使用：当你大量使用一个变量时，与其将它包含在每一个参数列表里面，不如把它设置成全局变量
5.  消除流浪数据：没读懂

****只有万不得已时才使用全局数据****

1.  首先把每一个变量设置局部的，仅当需要时才把变量设置为全局的：编程过程中，先设为局部变量，然后别的地方需要的情况下再设置为全局变量
2.  区分全局变量和类变量：类变量可以通过子程序来访问
3.  使用访问器子程序

****用访问器子程序来取代全局数据****

****访问器子程序的优势****

1.  获得了对数据的集中控制
2.  你可以确保对变量的所有引用都得到了保护
3.  你可以自动获得信息隐藏的普遍益处：访问器子程序允许你在不改变你房子外表的情况下戳鞥新装修内部
4.  访问器子程序可以很容易地转变为抽象数据类型：访问器子程序的一项优点是，让你可以创建一个很难用全局数据来直接创建的抽象层

****如何使用访问器子程序****

1.  要求所有的代码通过访问器子程序来存取数据
2.  不要把你所有的全局数据都扔在一处：对于全局变量不能按全局来分类处理，而是根据抽象模块化编程来处理
3.  用锁定来控制对全局变量的访问：对于多线程的程序，对全局变量的处理，一定要有锁定来确保数据是在未使用期间被改变，也就是有锁定/解锁来确保数据被正确的使用
4.  在你的访问器子程序里构建一个抽象层
5.  使得对一项数据的所有访问都发生在同一个抽象层上：其实最终可以归结于，对数据的处理用子程序来实现，那么所有的操作都要用子程序来实现，因为子程序能够比简单的赋值操作提供给阅读者更多的信息

****如何降低使用全局数据的风险****

1.  创建一种命名规则来突出全局变量
2.  为全部的全局变量创建一份注释良好的清单
3.  不要用全局变量来存放中间结果
4.  不要把所有的数据都放在一个大对象中并到处传递，以说明你没有使用全局变量：意思呢，就是用就明白的痛快的用，没必要藏着掖着

****要点****

1.  结构体可以使得程序更简单、更容易理解，以及更容易维护
2.  每当你打算使用结构体的时候，考虑采用类是不是回工作得更好
3.  指针很容易出错，用访问器子程序或类以及防御式编程实践来保护自己的代码
4.  避免用全局变量，不只是因为它们很危险，还是因为你可以用其他更好的方法来取代它们
5.  如果你不得不使用全局变量，那么就通过访问器子程序来使用它。访问器子程序能为你带来全局变量所能带来的一切优点，还有一些额外好处